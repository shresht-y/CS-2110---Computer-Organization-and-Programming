#include "main.h"

#include <stdio.h>
#include <stdlib.h>

#include "gba.h"
/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
// #include "images/garbage.h"
#include "images/TitleScreen.h"
#include "images/JJ.h"
#include "images/Flag.h"
#include "images/Win.h"
#include "images/End.h"

/* TODO: */
// Add any additional states you need for your app. You are not requried to use
// these specific provided states.
enum gba_state {
  START,
  PLAY,
  WIN,
  LOSE,
};

int main(void) {
  /* TODO: */
  // Manipulate REG_DISPCNT here to set Mode 3. //
  REG_DISPCNT = MODE3 | BG2_ENABLE;

  // Save current and previous state of button input.
  u32 previousButtons = BUTTONS;
  u32 currentButtons = BUTTONS;

  // Load initial application state
  enum gba_state state = START;

  struct Player p;
  while (1) {
    currentButtons = BUTTONS; // Load the current state of the buttons

    /* TODO: */
    // Manipulate the state machine below as needed //
    // NOTE: Call waitForVBlank() before you draw
    waitForVBlank();

    switch (state) {
      case START:
         // Load initial player state 
          p.row = 20;
          p.col = 20;
          p.meters = 0;

          int render = 0;

          vBlankCounter = 0;
        drawFullScreenImageDMA(TitleScreen);
        //drawString(130,80,"Press Start", WHITE);
        if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons) && KEY_DOWN(BUTTON_START, currentButtons)) {
          state = PLAY;
        }

        break;
      case PLAY:
        fillScreenDMA(BLACK);

        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons) && KEY_DOWN(BUTTON_SELECT, currentButtons)) {
          state = START;
        }


        if (vBlankCounter >= 1000) {
          p.meters = vBlankCounter;
          state = LOSE;
        }
        //drawScreen(p,m);
        if (KEY_JUST_PRESSED(BUTTON_UP, currentButtons,previousButtons) && KEY_DOWN(BUTTON_UP, currentButtons)) {
          p.row -=1;
        } else if (KEY_JUST_PRESSED(BUTTON_DOWN, currentButtons,previousButtons) && KEY_DOWN(BUTTON_DOWN, currentButtons)) {
          p.row +=1;
        } else if (KEY_JUST_PRESSED(BUTTON_RIGHT, currentButtons,previousButtons) && KEY_DOWN(BUTTON_RIGHT, currentButtons)) {
          p.col+=1;
        } else if (KEY_JUST_PRESSED(BUTTON_LEFT, currentButtons,previousButtons) && KEY_DOWN(BUTTON_LEFT, currentButtons)) {
          p.col-=1;
        }
        drawScreen(p);
        if (checkCollison(p) == 1) {
          p.meters = vBlankCounter;
          state = WIN;
        }
        break;
      case WIN:
        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons) && KEY_DOWN(BUTTON_SELECT, currentButtons)) {
          state = START;
        }
        if (render == 0) {
          drawFullScreenImageDMA(Win);
          char distance[32] = "";
          sprintf(distance, "Distance Traveled:%dm", p.meters);
          char* destinationString = distance;
          drawString(140, 80, destinationString, BLACK);
          drawString(120, 80, "You finished!", BLACK);
          render++;
        }
      
        break;
      case LOSE:
        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons) && KEY_DOWN(BUTTON_SELECT, currentButtons)) {
          state = START;
        }
        if (render ==0) {
          drawFullScreenImageDMA(End);
          char distance[32] = "";
          sprintf(distance, "Distance Traveled:%dm", p.meters);
          char* destinationString = distance;
          drawString(130, 50, destinationString, BLACK);
          drawString(110, 50, "You didnt make it", BLACK);
          render++;
        }
      break;
    }

    previousButtons = currentButtons; // Store the current state of the buttons
  }

 // You can remove this once previousButtons is used

  return 0;
}

void drawScreen(struct Player p) {
  drawImageDMA(p.row, p.col, JJ_WIDTH,JJ_HEIGHT,JJ);
  drawImageDMA(100,200, FLAG_WIDTH, FLAG_HEIGHT, Flag);
  
  char string[21] = "";
  sprintf(string, "Distance:%dm", vBlankCounter);
  char* destinationString = string;
  drawString(130, 10, destinationString, WHITE);
  
  waitForVBlank();
}


int checkCollison(struct Player p) { //goal is on 100 -> 112 length and 200 -> 219
  if (p.row + 19 >= 100 && p.row + 19 <= 112) { //bottom 
    if ((p.col >= 200 && p.col <= 219) || (p.col + 12 >= 200 && p.col +12 <= 219)) {
      return 1;
    }
  } else if (p.row >= 100 && p.row <= 112) { //top left 5
    if ((p.col >= 200 && p.col <= 219) || (p.col + 12 >= 200 && p.col +12 <= 219))  { 
      return 1;
    }
  } else if (p.col + 19 >= 200 && p.col + 19 <= 219) { //top right
    if (p.row >= 100 && p.row <= 112) {
      return 1;
    } 
  
  } else if (p.col >= 200 && p.col<= 219) {
    if (p.row + 19 >= 100 && p.row +19 <= 112) {
      return 1;
    }
  }
  return 0;
  
}